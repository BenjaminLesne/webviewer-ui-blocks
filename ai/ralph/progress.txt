## 2026-01-17: Story-001 Completed - Registry Structure and Build Pipeline

### What was done:
- Created `registry.json` at project root with:
  - Schema reference to shadcn registry schema
  - Project name and homepage
  - All 13 registry items defined (types, context, 3 hooks, 9 components)
  - Proper registry dependencies between items

- Created directory structure:
  - `registry/components/`
  - `registry/hooks/`
  - `registry/context/`
  - `registry/lib/`

- Created documentation directories:
  - `components/docs/`
  - `content/docs/components/`
  - `content/docs/hooks/`
  - `content/docs/context/`

- Updated `package.json`:
  - Added `shadcn` as dev dependency (^2.5.0)
  - Added `registry:build` script that runs `npx shadcn build`
  - Added `typecheck` alias script
  - Added placeholder `test` script

- Updated `eslint.config.mjs`:
  - Added `components/webviewer-legacy/**` to ignores (pre-existing legacy code)

### Notes for next developer:
- The project uses pnpm (has pnpm-lock.yaml), but npm commands work for most tasks
- There's an esbuild platform mismatch issue in the environment (darwin-arm64 vs linux-arm64) that prevents typecheck from running, but this is an environment issue, not a code issue
- Lint passes with only 1 warning (postcss.config.mjs anonymous export)
- All registry items are defined but the actual component/hook files in the registry/ directories still need to be implemented (story-002 onwards)
- Next story to work on: story-002 (Implement WebViewer types and context)

## 2026-01-17: Story-002 Completed - WebViewer Types and Context

### What was done:
- Created `registry/lib/webviewer-types.ts`:
  - Exports `DocumentViewer` type derived from Core.documentViewer
  - Exports `WebViewerContextValue` type with Core and documentViewer properties

- Created `registry/context/webviewer-context.tsx`:
  - Provides `WebViewerProvider` component that initializes Core and DocumentViewer
  - Accepts optional `workerPath` prop (defaults to NEXT_PUBLIC_PDFTRON_PATH env var)
  - Sets up Core worker path and enables full PDF support
  - Creates DocumentViewer instance with annotations enabled
  - Includes cleanup on unmount (closes document)
  - Exports `useWebViewerContext` hook for accessing the context

- Created `types/webviewer.d.ts`:
  - Type declarations for `@pdftron/webviewer` module
  - Extends global Window interface with `Core` and `PDFNet` properties
  - Enables type checking for registry files without requiring the actual package

- Updated `tsconfig.json`:
  - Added path aliases for registry files (`@/lib/webviewer-types`, `@/context/webviewer-context`, `@/hooks/*`)
  - Added path alias for `@pdftron/webviewer` pointing to local type declarations
  - Added `types/**/*.d.ts` to include array

### Verification:
- TypeScript: `npx tsc --noEmit` passes for registry files (no errors)
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- The esbuild platform mismatch issue persists (darwin-arm64 vs linux-arm64), preventing `npm run typecheck` from running, but `npx tsc --noEmit` works directly
- Registry files use `@/` path aliases which resolve in the consumer's project; tsconfig.json has overrides for local development
- The `types/webviewer.d.ts` provides minimal type stubs for development; consumers will get full types from @pdftron/webviewer package
- Next story to work on: story-003 (Implement core hooks)

## 2026-01-17: Story-003 Completed - Core Hooks

### What was done:
- Created `registry/hooks/use-core-instance.ts`:
  - Hook that accesses Core and documentViewer from WebViewerContext
  - Throws descriptive errors if used outside provider or before initialization
  - Returns guaranteed non-null Core and documentViewer instances

- Created `registry/hooks/use-run-with-license.ts`:
  - Hook for running PDFNet operations with automatic license key handling
  - Accepts optional licenseKey parameter (defaults to NEXT_PUBLIC_PDFTRON_LICENSE env var)
  - Returns a callback that wraps async operations with PDFNet.runWithCleanup
  - Includes error handling if PDFNet is not available

- Created `registry/hooks/use-zoom.ts`:
  - Hook for managing zoom level state and actions
  - Uses useSyncExternalStore to subscribe to documentViewer "zoomUpdated" events
  - Provides zoomLevel, zoomIn, zoomOut, and zoomTo functions
  - Implements zoom clamping (MIN_ZOOM=0.1, MAX_ZOOM=10, ZOOM_STEP=0.25)
  - Includes SSR-safe getServerSnapshot returning default zoom of 1

- Updated `tsconfig.json`:
  - Added `components/webviewer-legacy` to exclude array (fixes pre-existing type errors from legacy code)

### Verification:
- TypeScript: `npx tsc --noEmit` shows no errors in registry/ files
  - Note: Pre-existing errors in app/ files (LayoutProps, PageProps, RouteContext) require a Next.js build to generate types
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- The three hooks follow consistent patterns with "use client" directive for React hooks
- All hooks use the @/ path aliases that will resolve correctly in consumer projects
- The use-zoom hook is designed for UI components to stay synchronized with actual viewer zoom level
- Next story to work on: story-004 (Implement script loader components)

## 2026-01-17: Story-004 Completed - Script Loader Components

### What was done:
- Created `registry/components/load-webviewer-core.tsx`:
  - Dynamically loads webviewer-core.min.js using Next.js Script component
  - Uses "afterInteractive" strategy for script loading
  - Tracks ready state with retry logic (100ms delay) in case Core initializes asynchronously
  - Accepts `pdftronPath` prop (defaults to NEXT_PUBLIC_PDFTRON_PATH env var or "/webviewer/lib")
  - Supports custom `loadingUI` and `errorUI` props for customizing loading/error states
  - Provides `onLoad` and `onError` callbacks for external handling

- Created `registry/components/load-pdfnet.tsx`:
  - Dynamically loads PDFNet.js using Next.js Script component
  - Uses module-level `pdfnetScriptLoaded` flag to prevent duplicate loading
  - Accepts same props as LoadWebviewerCore for consistency (pdftronPath, loadingUI, errorUI, onLoad, onError)
  - Script path is `${pdftronPath}/core/pdf/PDFNet.js`

### Acceptance Criteria Met:
- ✓ registry/components/load-webviewer-core.tsx loads webviewer-core.min.js with loading/error states
- ✓ registry/components/load-pdfnet.tsx loads PDFNet.js with loading/error states
- ✓ Both components accept pdftronPath prop with NEXT_PUBLIC_PDFTRON_PATH env var default
- ✓ Both components support custom loading and error UI via props

### Verification:
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- Both components use the same prop interface pattern for consistency
- LoadWebviewerCore has retry logic because window.Core may initialize asynchronously after script load
- LoadPDFNet uses a module-level flag to track script load status across component instances
- The default pdftronPath is "/webviewer/lib", with "/core" or "/core/pdf" appended for the specific scripts
- Next story to work on: story-005 (Implement viewer components)

## 2026-01-17: Story-005 Completed - Viewer Components

### What was done:
- Created `registry/components/viewer-element.tsx`:
  - Sets documentViewer.setViewerElement on mount using a ref
  - Cleans up on unmount by setting element to null
  - Accepts `className` and `style` props for customization
  - Uses useCoreInstance hook to access documentViewer

- Created `registry/components/scroll-view-container.tsx`:
  - Sets documentViewer.setScrollViewElement on mount using a ref
  - Cleans up on unmount by setting element to null
  - Accepts `className`, `style`, and `children` props
  - Uses useCoreInstance hook to access documentViewer

- Created `registry/components/viewer-canvas.tsx`:
  - Composite component that combines ScrollViewContainer and ViewerElement
  - Accepts `className` and `style` for the outer ScrollViewContainer
  - Accepts `viewerClassName` and `viewerStyle` for the inner ViewerElement
  - Provides a convenient single component for rendering the PDF canvas

- Updated `tsconfig.json`:
  - Added path aliases for viewer components (`@/components/viewer-element`, `@/components/scroll-view-container`, `@/components/viewer-canvas`)
  - Used specific path aliases instead of wildcard to avoid conflict with existing `@/components/*` resolving to `./components/*`

### Acceptance Criteria Met:
- registry/components/viewer-element.tsx sets documentViewer.setViewerElement on mount
- registry/components/scroll-view-container.tsx sets documentViewer.setScrollViewElement on mount
- registry/components/viewer-canvas.tsx combines ScrollViewContainer and ViewerElement
- All components support className and style props for customization

### Verification:
- TypeScript: `npx tsc --noEmit` shows no errors in registry/ files
  - Pre-existing errors in app/ files (LayoutProps, PageProps, RouteContext) still require Next.js build to generate types
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- All three components follow consistent patterns with "use client" directive
- ViewerCanvas is the main component users will typically use; ViewerElement and ScrollViewContainer are for advanced use cases
- The components must be used within a WebViewerProvider context (enforced by useCoreInstance hook)
- Next story to work on: story-006 (Implement Document component)

## 2026-01-17: Story-006 Completed - Document Component

### What was done:
- Created `registry/components/document.tsx`:
  - Loads PDF documents via `documentPath` prop
  - Uses `@tanstack/react-query`'s `useMutation` for document loading with built-in state management
  - Supports both relative paths (e.g., "/documents/sample.pdf") and absolute URLs
  - Provides `onLoad` callback fired when document loads successfully
  - Provides `onError` callback fired when loading fails
  - Tracks previous path to avoid reloading on re-renders
  - Non-visual component (returns null)

- Added `@tanstack/react-query` as a dependency in package.json

- Updated `tsconfig.json`:
  - Added path alias `@/components/document` pointing to registry file

### Acceptance Criteria Met:
- ✓ registry/components/document.tsx loads documents via documentPath prop
- ✓ Component uses @tanstack/react-query for mutation handling
- ✓ Component supports both relative and absolute URLs
- ✓ onLoad and onError callbacks are supported

### Verification:
- TypeScript: `npx tsc --noEmit` shows no errors in registry/ files
  - Pre-existing errors in app/ files (LayoutProps, PageProps, RouteContext) still require Next.js build to generate types
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- The Document component is non-visual and should be used alongside ViewerCanvas within WebViewerProvider
- Uses useMutation from react-query which provides loading, error, and success states internally
- The component tracks the previous documentPath to prevent unnecessary reloads when the component re-renders
- Consumer projects need to wrap their app with QueryClientProvider from @tanstack/react-query
- Next story to work on: story-007 (Implement zoom control components)

## 2026-01-17: Story-007 Completed - Zoom Control Components

### What was done:
- Created `registry/components/zoom-controls.tsx`:
  - Simple zoom controls with +/- buttons and percentage display
  - Uses useZoom hook for zoom state (zoomLevel, zoomIn, zoomOut)
  - Displays current zoom as percentage (e.g., "100%")
  - Supports className, style, buttonClassName, and displayClassName props
  - Buttons have proper aria-labels for accessibility

- Created `registry/components/zoomer.tsx`:
  - Modern vertical zoom UI with + button on top, - button on bottom
  - Editable input field for direct zoom percentage entry
  - Input syncs automatically with actual zoom level via useEffect
  - Supports percentage input (e.g., "150%") and decimal input (e.g., "1.5")
  - Enter key applies input value, Escape key cancels edit
  - On blur, parses input and applies zoom (values > 10 treated as percentage)
  - Supports className, style, buttonClassName, and inputClassName props

- Updated `tsconfig.json`:
  - Added path aliases for `@/components/zoom-controls` and `@/components/zoomer`

### Acceptance Criteria Met:
- ✓ registry/components/zoom-controls.tsx provides simple +/- zoom buttons with percentage display
- ✓ registry/components/zoomer.tsx provides modern vertical zoom UI with editable input
- ✓ Both components use the useZoom hook for zoom state and actions
- ✓ Zoomer syncs input value with actual zoom level

### Verification:
- TypeScript: No errors in registry/ files (`npx tsc --noEmit`)
  - Pre-existing errors in app/ files still require Next.js build to generate types
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- Both components follow the same styling pattern: they render unstyled by default and rely on className props
- ZoomControls is horizontal layout (flat flex), Zoomer is designed for vertical layout
- Zoomer's input parsing is smart: values > 10 are treated as percentages (e.g., "150" → 1.5 zoom), values ≤ 10 are treated as zoom multipliers
- Both components are client components ("use client") and must be used within WebViewerProvider context
- Next story to work on: story-008 (Create documentation navigation structure)

## 2026-01-17: Story-008 Completed - Documentation Navigation Structure

### What was done:
- Created `content/docs/meta.json`:
  - Root-level navigation: index, Getting Started separator, context, hooks, components
  - Order reflects dependency hierarchy (context first, then hooks, then components)

- Created `content/docs/components/meta.json`:
  - Lists all 8 component pages in dependency order
  - Script loaders first (load-webviewer-core, load-pdfnet)
  - Viewer components next (viewer-element, scroll-view-container, viewer-canvas)
  - Feature components last (document, zoom-controls, zoomer)

- Created `content/docs/hooks/meta.json`:
  - Lists all 3 hook pages in dependency order
  - use-core-instance (base hook), use-run-with-license, use-zoom

- Created `content/docs/context/meta.json`:
  - Lists context page: webviewer-context

- Removed `.gitkeep` files from docs directories (no longer needed with meta.json files)

### Acceptance Criteria Met:
- content/docs/components/meta.json lists all component pages in correct order
- content/docs/hooks/meta.json lists all hook pages
- content/docs/context/meta.json lists context pages
- Navigation structure matches the dependency hierarchy

### Verification:
- TypeScript: No new errors (pre-existing Next.js generated types errors remain)
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- The meta.json files use Fumadocs format with `title`, `description`, and `pages` array
- The `pages` array contains slugs (filenames without .mdx extension)
- Root meta.json uses `---Getting Started---` separator syntax for navigation grouping
- The MDX documentation pages themselves still need to be created (story-010)
- Next story to work on: story-009 (Create documentation helper components)

## 2026-01-17: Story-009 Completed - Documentation Helper Components

### What was done:
- Created `components/docs/install-command.tsx`:
  - Shows copyable `npx shadcn@latest add <registry-url>/<name>.json` command
  - Uses `useCopyButton` from fumadocs-ui for copy state management
  - Displays checkmark icon on successful copy
  - Dynamically constructs the full URL using window.location.origin
  - Accepts `name` prop for the registry item name and `className` for styling

- Created `components/docs/component-source.tsx`:
  - Server component that reads registry source files directly from disk
  - Uses `DynamicCodeBlock` from fumadocs-ui for syntax highlighting
  - Supports four registry types: component, hook, context, and lib
  - Maps types to their respective directories and file extensions
  - Graceful error handling when files cannot be loaded
  - Accepts `name`, `type`, and `className` props

### Acceptance Criteria Met:
- components/docs/install-command.tsx shows copyable npx shadcn add command
- components/docs/component-source.tsx displays component source code from registry files
- Copy button works and shows feedback on InstallCommand
- ComponentSource handles component, hook, context, and lib types

### Verification:
- Build: `npm run build` passes (TypeScript compiles successfully within Next.js)
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- InstallCommand is a client component ("use client") that runs in the browser
- ComponentSource is a server component that reads files at build/render time
- Both components use fumadocs-ui utilities for consistent styling and behavior
- The typeToPath and typeToExtension mappings in ComponentSource match the registry.json structure
- Next story to work on: story-010 (Create MDX documentation pages)

## 2026-01-17: Story-010 Completed - MDX Documentation Pages

### What was done:
- Updated `content/docs/index.mdx`:
  - Transformed into a comprehensive "Getting Started" guide
  - Documents prerequisites (Next.js, WebViewer license, public folder setup)
  - Step-by-step setup instructions for WebViewer, environment variables, React Query
  - Quick start example showing a minimal PDF viewer
  - Component hierarchy diagram showing nesting requirements
  - Links to context, hooks, and components documentation

- Created `content/docs/context/webviewer-context.mdx`:
  - Documents WebViewerProvider component and useWebViewerContext hook
  - Props table for WebViewerProvider (children, workerPath)
  - Context value documentation (Core, documentViewer)
  - Environment variables section

- Created hook documentation pages:
  - `content/docs/hooks/use-core-instance.mdx`: Guaranteed non-null Core/documentViewer access with error handling
  - `content/docs/hooks/use-run-with-license.mdx`: PDFNet license wrapper with async operation support
  - `content/docs/hooks/use-zoom.mdx`: Reactive zoom state with useSyncExternalStore

- Created component documentation pages (8 total):
  - `content/docs/components/load-webviewer-core.mdx`: Script loader with loading/error states
  - `content/docs/components/load-pdfnet.mdx`: PDFNet script loader
  - `content/docs/components/viewer-element.mdx`: PDF rendering element
  - `content/docs/components/scroll-view-container.mdx`: Scrollable container
  - `content/docs/components/viewer-canvas.mdx`: Composite viewer component
  - `content/docs/components/document.mdx`: Document loading with react-query
  - `content/docs/components/zoom-controls.mdx`: Simple +/- zoom UI
  - `content/docs/components/zoomer.mdx`: Modern zoom UI with editable input

- Removed `content/docs/test.mdx` (no longer needed)

### Documentation Features:
- Each page includes InstallCommand component showing `npx shadcn@latest add` command
- Each page includes ComponentSource showing the actual source code
- Props tables for all components
- Usage examples with code snippets
- Notes about prerequisites and context requirements

### Acceptance Criteria Met:
- ✓ Each component has an MDX page with installation command, usage example, props table, and source
- ✓ Each hook has an MDX page with installation, usage, and API documentation
- ✓ Context page documents WebViewerProvider and useWebViewerContext
- ✓ Installation page explains environment variables and setup steps

### Verification:
- TypeScript: `npx tsc --noEmit` passes (no errors)
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)

### Notes for next developer:
- All MDX pages use the documentation helper components (InstallCommand, ComponentSource)
- Pages follow consistent structure: Installation → Usage → Props → Notes → Source
- The index.mdx serves as both landing page and setup guide
- Next story to work on: story-011 (Build and verify registry)

## 2026-01-18: Story-011 Completed - Build and Verify Registry

### What was done:
- Ran `npx shadcn build` which successfully generated 13 JSON files in `public/r/`:
  - document.json, load-pdfnet.json, load-webviewer-core.json
  - scroll-view-container.json, viewer-canvas.json, viewer-element.json
  - use-core-instance.json, use-run-with-license.json, use-zoom.json
  - webviewer-context.json, webviewer-types.json
  - zoom-controls.json, zoomer.json

- Verified all JSON files are valid:
  - Each file validates with `jq` parser
  - Files include correct schema reference ($schema pointing to shadcn registry-item.json)
  - File contents are correctly embedded in the "files" array
  - npm dependencies (e.g., @tanstack/react-query) are correctly specified
  - registryDependencies correctly reference other registry items

- Verified all registry dependencies resolve correctly:
  - All registryDependencies have corresponding JSON files in public/r/
  - Dependency chain is complete (e.g., zoomer → use-zoom → use-core-instance → webviewer-context → webviewer-types)

- Fixed build error in `content/docs/index.mdx`:
  - Changed code block language from `env` to `bash` (Shiki doesn't have built-in `env` language support)

- Ran `npm run build` which completed successfully:
  - 44 static pages generated
  - All documentation routes working
  - TypeScript compilation passed

### Acceptance Criteria Met:
- ✓ npx shadcn build generates public/r/*.json files for all registry items (13 files)
- ✓ All generated JSON files are valid and include correct file contents
- ✓ Registry dependencies resolve correctly in generated files
- ✓ npm run build completes without errors

### Verification:
- TypeScript: `npm run typecheck` passes (types generated successfully)
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)
- Build: `npm run build` passes (44 pages generated)

### Notes for next developer:
- The public/r/ directory now contains all registry JSON files ready for consumption
- Registry items can be installed via `npx shadcn@latest add <url>/r/<component>.json`
- The `env` language is not supported by Shiki; use `bash` for environment variable examples in MDX
- Next story to work on: story-012 (Test installation flow)

## 2026-01-18: Story-012 Completed - Test Installation Flow

### What was done:
- Updated `registry.json` to use full URLs for `registryDependencies`:
  - Changed from simple name references (e.g., `"webviewer-types"`) to full URLs
  - Format: `"https://webviewer-ui-blocks.vercel.app/r/<item>.json"`
  - This is required because shadcn CLI resolves unqualified names against the default shadcn registry

- Tested installation flow in a fresh Next.js project:
  1. Created `/tmp/shadcn-test-project` with `npx create-next-app@latest`
  2. Initialized shadcn with `npx shadcn@latest init -d`
  3. Successfully installed components using `npx shadcn@latest add http://localhost:3000/r/<component>.json`

- Verified all acceptance criteria:
  - **Files created in correct locations**:
    - Components → `src/components/`
    - Hooks → `src/hooks/`
    - Lib (types, context) → `src/lib/`
  - **npm dependencies added to package.json**:
    - `@pdftron/webviewer` (from webviewer-context)
    - `@tanstack/react-query` (from document component)
  - **Registry dependencies automatically installed**:
    - Installing `document.json` automatically installed: use-core-instance, webviewer-context, webviewer-types
    - Installing `viewer-canvas.json` automatically installed: scroll-view-container, viewer-element, use-core-instance, webviewer-context, webviewer-types

### Technical Details:
- The shadcn CLI (v2.10.0) requires full URLs for cross-registry dependencies
- The `local:` prefix syntax mentioned in some documentation did not work - CLI still tried to resolve against default registry
- Full URLs work correctly and allow the CLI to fetch dependencies from our custom registry

### Acceptance Criteria Met:
- ✓ npx shadcn add <url>/r/viewer-canvas.json installs all dependencies correctly
- ✓ Files are created in correct locations matching user's components.json paths
- ✓ npm dependencies (@pdftron/webviewer, etc.) are added to package.json
- ✓ Registry dependencies are automatically installed

### Verification:
- TypeScript: `npm run typecheck` passes
- Lint: `npm run lint` passes (only pre-existing postcss.config.mjs warning)
- Tests: `npm test` passes (placeholder test script)
- Build: `npm run build` passes

### Notes for next developer:
- All 12 stories are now complete - the PRD is finished!
- The registry is ready for deployment to Vercel
- After deployment, users can install components with:
  `npx shadcn@latest add https://webviewer-ui-blocks.vercel.app/r/<component>.json`
- Consumer projects need to set up their own type declarations for `window.Core` and `window.PDFNet`
- The @pdftron/webviewer package provides types but the global Window interface extension is project-specific
