# Implementation Plan: webviewer-ui-blocks Registry

A shadcn-style component registry for Apryse WebViewer UI components using Fumadocs + native shadcn CLI.

## Overview

**Registry Name:** `webviewer-ui-blocks`
**Tech Stack:** Next.js 16 + Fumadocs + shadcn Registry
**CLI:** Native `npx shadcn add <url>` (no custom CLI needed)
**Hosting:** Vercel (recommended)
**Source Reference:** `components/webviewer-legacy/webviewer-v3/`

---

## Repository Structure

```
webviewer-ui-blocks/
├── app/                                # Already exists
│   ├── layout.tsx
│   ├── (home)/page.tsx
│   ├── docs/[[...slug]]/page.tsx
│   └── api/search/route.ts
├── content/
│   └── docs/
│       ├── index.mdx                   # Already exists
│       ├── installation.mdx            # To create
│       ├── components/
│       │   ├── meta.json
│       │   ├── load-webviewer-core.mdx
│       │   ├── load-pdfnet.mdx
│       │   ├── webviewer-provider.mdx
│       │   ├── viewer-canvas.mdx
│       │   ├── viewer-element.mdx
│       │   ├── scroll-view-container.mdx
│       │   ├── document.mdx
│       │   ├── zoom-controls.mdx
│       │   └── zoomer.mdx
│       ├── hooks/
│       │   ├── meta.json
│       │   ├── use-core-instance.mdx
│       │   ├── use-zoom.mdx
│       │   └── use-run-with-license.mdx
│       └── context/
│           ├── meta.json
│           └── webviewer-context.mdx
├── registry/                           # To create
│   ├── components/
│   │   ├── load-webviewer-core.tsx
│   │   ├── load-pdfnet.tsx
│   │   ├── webviewer-provider.tsx
│   │   ├── viewer-canvas.tsx
│   │   ├── viewer-element.tsx
│   │   ├── scroll-view-container.tsx
│   │   ├── document.tsx
│   │   ├── zoom-controls.tsx
│   │   └── zoomer.tsx
│   ├── hooks/
│   │   ├── use-core-instance.ts
│   │   ├── use-zoom.ts
│   │   └── use-run-with-license.ts
│   ├── context/
│   │   └── webviewer-context.tsx
│   └── lib/
│       └── webviewer-types.ts
├── public/
│   └── r/                              # Generated by `npx shadcn build`
│       ├── load-webviewer-core.json
│       ├── webviewer-provider.json
│       └── ...
├── components/
│   └── docs/                           # To create
│       ├── component-source.tsx
│       ├── install-command.tsx
│       └── dependencies-list.tsx
├── lib/
│   ├── cn.ts                           # Already exists
│   └── source.ts                       # Already exists
├── registry.json                       # To create
├── components.json                     # To create (shadcn config)
└── package.json                        # Already exists
```

---

## registry.json

```json
{
  "$schema": "https://ui.shadcn.com/schema/registry.json",
  "name": "webviewer-ui-blocks",
  "homepage": "https://webviewer-ui-blocks.vercel.app",
  "items": [
    {
      "name": "webviewer-types",
      "type": "registry:lib",
      "title": "WebViewer Types",
      "description": "TypeScript types for Core and DocumentViewer",
      "dependencies": ["@pdftron/webviewer"],
      "files": [{ "path": "registry/lib/webviewer-types.ts", "type": "registry:lib" }]
    },
    {
      "name": "webviewer-context",
      "type": "registry:component",
      "title": "WebViewer Context",
      "description": "React context provider for Apryse Core and DocumentViewer instances",
      "dependencies": ["@pdftron/webviewer"],
      "registryDependencies": ["webviewer-types"],
      "files": [
        {
          "path": "registry/context/webviewer-context.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "use-core-instance",
      "type": "registry:hook",
      "title": "useCoreInstance",
      "description": "Hook to access Core and documentViewer from context",
      "registryDependencies": ["webviewer-context"],
      "files": [
        {
          "path": "registry/hooks/use-core-instance.ts",
          "type": "registry:hook"
        }
      ]
    },
    {
      "name": "use-run-with-license",
      "type": "registry:hook",
      "title": "useRunWithLicense",
      "description": "Hook to run PDFNet operations with Apryse license",
      "registryDependencies": ["use-core-instance"],
      "files": [
        {
          "path": "registry/hooks/use-run-with-license.ts",
          "type": "registry:hook"
        }
      ]
    },
    {
      "name": "use-zoom",
      "type": "registry:hook",
      "title": "useZoom",
      "description": "Hook for zoom control synced with documentViewer",
      "registryDependencies": ["use-core-instance"],
      "files": [
        { "path": "registry/hooks/use-zoom.ts", "type": "registry:hook" }
      ]
    },
    {
      "name": "load-webviewer-core",
      "type": "registry:component",
      "title": "LoadWebviewerCore",
      "description": "Loads Apryse WebViewer Core script dynamically",
      "dependencies": ["@pdftron/webviewer"],
      "files": [
        {
          "path": "registry/components/load-webviewer-core.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "load-pdfnet",
      "type": "registry:component",
      "title": "LoadPDFNet",
      "description": "Loads PDFNet library for advanced PDF operations",
      "dependencies": ["@pdftron/webviewer"],
      "files": [
        {
          "path": "registry/components/load-pdfnet.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "webviewer-provider",
      "type": "registry:component",
      "title": "WebViewerProvider",
      "description": "Provider component that initializes Core and DocumentViewer",
      "registryDependencies": ["webviewer-context"],
      "files": [
        {
          "path": "registry/components/webviewer-provider.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "viewer-element",
      "type": "registry:component",
      "title": "ViewerElement",
      "description": "DOM container for WebViewer canvas",
      "registryDependencies": ["use-core-instance"],
      "files": [
        {
          "path": "registry/components/viewer-element.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "scroll-view-container",
      "type": "registry:component",
      "title": "ScrollViewContainer",
      "description": "Scrollable container for the document",
      "registryDependencies": ["use-core-instance"],
      "files": [
        {
          "path": "registry/components/scroll-view-container.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "viewer-canvas",
      "type": "registry:component",
      "title": "ViewerCanvas",
      "description": "Composite viewer component combining scroll and canvas",
      "registryDependencies": ["scroll-view-container", "viewer-element"],
      "files": [
        {
          "path": "registry/components/viewer-canvas.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "document",
      "type": "registry:component",
      "title": "Document",
      "description": "Loads a PDF document into the viewer",
      "dependencies": ["@tanstack/react-query", "zod"],
      "registryDependencies": ["use-core-instance", "use-run-with-license"],
      "files": [
        {
          "path": "registry/components/document.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "zoom-controls",
      "type": "registry:component",
      "title": "ZoomControls",
      "description": "Simple zoom UI with +/- buttons",
      "registryDependencies": ["use-zoom"],
      "files": [
        {
          "path": "registry/components/zoom-controls.tsx",
          "type": "registry:component"
        }
      ]
    },
    {
      "name": "zoomer",
      "type": "registry:component",
      "title": "Zoomer",
      "description": "Modern vertical zoom control with editable input",
      "dependencies": ["lucide-react", "clsx", "tailwind-merge"],
      "registryDependencies": ["use-zoom", "button", "input"],
      "files": [
        {
          "path": "registry/components/zoomer.tsx",
          "type": "registry:component"
        }
      ]
    }
  ]
}
```

---

## Implementation Steps

### Phase 1: shadcn Registry Setup

1. **Initialize shadcn**

   ```bash
   npx shadcn@latest init
   ```

2. **Add required shadcn components for the site**
   ```bash
   npx shadcn@latest add button input tabs card
   ```

3. **Create `registry.json`** at project root (as shown above)

4. **Create the registry directory structure**
   ```bash
   mkdir -p registry/{components,hooks,context,lib}
   mkdir -p components/docs
   mkdir -p content/docs/{components,hooks,context}
   ```

---

### Phase 2: Component Implementation

#### 2.1 Types - `registry/lib/webviewer-types.ts`

```typescript
import type { Core } from "@pdftron/webviewer";

export type DocumentViewer = (typeof Core)["documentViewer"];

export type WebViewerContextValue = {
  Core: typeof Core | null;
  documentViewer: DocumentViewer | null;
};
```

---

#### 2.2 Context - `registry/context/webviewer-context.tsx`

**Changes from original:**
- Removed `usePDFTronPath` → use `NEXT_PUBLIC_PDFTRON_PATH` env var
- Removed `useHypertuneFlags` → removed DEBUG logging
- Removed `useRefSync` → use `useCallback` with ref pattern

```typescript
"use client";

import {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
  useRef,
  type PropsWithChildren,
} from "react";
import type { WebViewerContextValue } from "@/lib/webviewer-types";

const WebViewerContext = createContext<WebViewerContextValue>({
  Core: null,
  documentViewer: null,
});

type WebViewerProviderProps = PropsWithChildren<{
  /** Path to PDFTron library files. Defaults to NEXT_PUBLIC_PDFTRON_PATH env var */
  pdftronPath?: string;
}>;

export const WebViewerProvider = ({
  children,
  pdftronPath = process.env.NEXT_PUBLIC_PDFTRON_PATH ?? "/webviewer/lib",
}: WebViewerProviderProps) => {
  const workerPath = `${pdftronPath}/core`;

  const [state] = useState(() => {
    const CoreInstance = window.Core!;

    CoreInstance.setWorkerPath(workerPath);
    CoreInstance.enableFullPDF();

    const docViewer = new CoreInstance.DocumentViewer();
    docViewer.enableAnnotations();

    return {
      Core: CoreInstance,
      documentViewer: docViewer,
    };
  });

  const stateRef = useRef(state);
  stateRef.current = state;

  const cleanup = useCallback(() => {
    if (stateRef.current.documentViewer) {
      try {
        void stateRef.current.documentViewer.closeDocument();
      } catch {
        // DocumentViewer might not have a document loaded
      }
    }
  }, []);

  useEffect(() => {
    return cleanup;
  }, [cleanup]);

  return (
    <WebViewerContext.Provider value={state}>
      {children}
    </WebViewerContext.Provider>
  );
};

export const useWebViewerContext = () => useContext(WebViewerContext);
```

---

#### 2.3 Hooks

##### `registry/hooks/use-core-instance.ts`

```typescript
"use client";

import { useWebViewerContext } from "@/context/webviewer-context";

export const useCoreInstance = () => {
  const { Core, documentViewer } = useWebViewerContext();

  if (!Core || !documentViewer) {
    throw new Error(
      "WebViewer is not initialized. Make sure to wrap your component with LoadWebviewerCore and WebViewerProvider."
    );
  }

  return { Core, documentViewer };
};
```

##### `registry/hooks/use-run-with-license.ts`

**Changes from original:**
- Replaced `env.NEXT_PUBLIC_APRYSE_LICENSE_WEB` → `process.env.NEXT_PUBLIC_APRYSE_LICENSE`

```typescript
"use client";

import type { Core } from "@pdftron/webviewer";
import { useCoreInstance } from "@/hooks/use-core-instance";

type PDFNetOperation<T> = () => Promise<T>;

export const useRunWithLicense = () => {
  const { Core } = useCoreInstance();

  return async <T>(operation: PDFNetOperation<T>): Promise<T> => {
    const license = process.env.NEXT_PUBLIC_APRYSE_LICENSE ?? "";
    return Core.PDFNet.runWithCleanup(operation, license);
  };
};
```

##### `registry/hooks/use-zoom.ts`

```typescript
"use client";

import { useSyncExternalStore } from "react";
import { useCoreInstance } from "@/hooks/use-core-instance";

const ZOOM_STEP = 0.25;
const MIN_ZOOM = 0.25;

export const useZoom = () => {
  const { documentViewer } = useCoreInstance();

  const zoomLevel = useSyncExternalStore(
    (onStoreChange) => {
      documentViewer.addEventListener("zoomUpdated", onStoreChange);
      return () => documentViewer.removeEventListener("zoomUpdated", onStoreChange);
    },
    () => documentViewer.getZoomLevel()
  );

  const zoomIn = () => documentViewer.zoomTo(zoomLevel + ZOOM_STEP);
  const zoomOut = () => documentViewer.zoomTo(Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP));
  const zoomTo = (level: number) => documentViewer.zoomTo(Math.max(MIN_ZOOM, level));

  return { zoomLevel, zoomIn, zoomOut, zoomTo };
};
```

---

#### 2.4 Components

##### `registry/components/load-webviewer-core.tsx`

**Changes from original:**
- Removed `usePDFTronPath` → accept as prop with env var default
- Removed `useHypertuneFlags` → removed DEBUG logging

```typescript
"use client";

import { useState, useEffect, useRef, type PropsWithChildren } from "react";
import Script from "next/script";

type LoadWebviewerCoreProps = PropsWithChildren<{
  /** Path to PDFTron library files. Defaults to NEXT_PUBLIC_PDFTRON_PATH env var */
  pdftronPath?: string;
  /** Custom loading component */
  loading?: React.ReactNode;
  /** Custom error component */
  error?: React.ReactNode;
}>;

export const LoadWebviewerCore = ({
  children,
  pdftronPath = process.env.NEXT_PUBLIC_PDFTRON_PATH ?? "/webviewer/lib",
  loading = <div>Loading WebViewer...</div>,
  error: errorComponent = <div>Failed to load WebViewer Core script</div>,
}: LoadWebviewerCoreProps) => {
  const [ready, setReady] = useState(
    () => typeof window !== "undefined" && !!window.Core
  );
  const [error, setError] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (window.Core) {
      setReady(true);
    }

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  if (error) {
    return <>{errorComponent}</>;
  }

  return (
    <>
      <Script
        src={`${pdftronPath}/core/webviewer-core.min.js`}
        strategy="afterInteractive"
        onLoad={() => {
          if (window.Core) {
            setReady(true);
          } else {
            timeoutRef.current = setTimeout(() => {
              if (window.Core) {
                setReady(true);
              } else {
                setError(true);
              }
            }, 100);
          }
        }}
        onError={() => {
          if (!window.Core) {
            setError(true);
          }
        }}
      />
      {ready ? children : loading}
    </>
  );
};
```

##### `registry/components/load-pdfnet.tsx`

```typescript
"use client";

import { useState, useEffect, type PropsWithChildren } from "react";
import Script from "next/script";

let pdfnetScriptLoaded = false;

type LoadPDFNetProps = PropsWithChildren<{
  /** Path to PDFTron library files. Defaults to NEXT_PUBLIC_PDFTRON_PATH env var */
  pdftronPath?: string;
  /** Custom loading component */
  loading?: React.ReactNode;
  /** Custom error component */
  error?: React.ReactNode;
}>;

export const LoadPDFNet = ({
  children,
  pdftronPath = process.env.NEXT_PUBLIC_PDFTRON_PATH ?? "/webviewer/lib",
  loading = <div>Loading PDFNet...</div>,
  error: errorComponent = <div>Failed to load PDFNet script</div>,
}: LoadPDFNetProps) => {
  const [ready, setReady] = useState(() => pdfnetScriptLoaded);
  const [error, setError] = useState(false);

  useEffect(() => {
    if (pdfnetScriptLoaded) {
      setReady(true);
    }
  }, []);

  if (error) {
    return <>{errorComponent}</>;
  }

  return (
    <>
      <Script
        src={`${pdftronPath}/core/pdf/PDFNet.js`}
        strategy="afterInteractive"
        onLoad={() => {
          pdfnetScriptLoaded = true;
          setReady(true);
        }}
        onError={() => {
          setError(true);
        }}
      />
      {ready ? children : loading}
    </>
  );
};
```

##### `registry/components/viewer-element.tsx`

```typescript
"use client";

import { useRef, useEffect, useState, type ReactNode } from "react";
import { useCoreInstance } from "@/hooks/use-core-instance";

interface ViewerElementProps {
  children?: ReactNode;
  className?: string;
  style?: React.CSSProperties;
}

export const ViewerElement = ({
  children,
  className,
  style,
}: ViewerElementProps) => {
  const viewerRef = useRef<HTMLDivElement>(null);
  const [isReady, setIsReady] = useState(false);
  const { documentViewer } = useCoreInstance();

  useEffect(() => {
    if (viewerRef.current) {
      documentViewer.setViewerElement(viewerRef.current);
      setIsReady(true);
    }
  }, [documentViewer]);

  return (
    <div
      ref={viewerRef}
      className={className}
      style={{
        width: "100%",
        height: "100%",
        minHeight: "100%",
        ...style,
      }}
    >
      {isReady && children}
    </div>
  );
};
```

##### `registry/components/scroll-view-container.tsx`

```typescript
"use client";

import { useRef, useEffect, useState, type ReactNode } from "react";
import { useCoreInstance } from "@/hooks/use-core-instance";

interface ScrollViewContainerProps {
  children?: ReactNode;
  className?: string;
  style?: React.CSSProperties;
}

export const ScrollViewContainer = ({
  children,
  className,
  style,
}: ScrollViewContainerProps) => {
  const scrollViewRef = useRef<HTMLDivElement>(null);
  const [isReady, setIsReady] = useState(false);
  const { documentViewer } = useCoreInstance();

  useEffect(() => {
    if (scrollViewRef.current) {
      documentViewer.setScrollViewElement(scrollViewRef.current);
      setIsReady(true);
    }
  }, [documentViewer]);

  return (
    <div
      ref={scrollViewRef}
      className={className}
      style={{
        flex: 1,
        overflow: "auto",
        position: "relative",
        ...style,
      }}
    >
      {isReady && children}
    </div>
  );
};
```

##### `registry/components/viewer-canvas.tsx`

```typescript
"use client";

import { type ReactNode } from "react";
import { ScrollViewContainer } from "@/components/scroll-view-container";
import { ViewerElement } from "@/components/viewer-element";

interface ViewerCanvasProps {
  children?: ReactNode;
  className?: string;
}

export const ViewerCanvas = ({ children, className }: ViewerCanvasProps) => {
  return (
    <ScrollViewContainer className={className}>
      <ViewerElement>{children}</ViewerElement>
    </ScrollViewContainer>
  );
};
```

##### `registry/components/document.tsx`

**Changes from original:**
- Removed `useRefSync` → use `useCallback` with ref pattern
- Removed `useHypertuneFlags` → removed DEBUG logging

```typescript
"use client";

import { useEffect, useCallback, useRef } from "react";
import { useMutation } from "@tanstack/react-query";
import { z } from "zod";
import { useCoreInstance } from "@/hooks/use-core-instance";
import { useRunWithLicense } from "@/hooks/use-run-with-license";

type DocumentProps = {
  /** Path to the PDF document (relative or absolute URL) */
  documentPath: string;
  /** Callback when document loads successfully */
  onLoad?: () => void;
  /** Callback when document fails to load */
  onError?: (error: Error) => void;
};

export const Document = ({ documentPath, onLoad, onError }: DocumentProps) => {
  const { documentViewer } = useCoreInstance();
  const runWithLicense = useRunWithLicense();

  const { mutate } = useMutation({
    mutationFn: async () => {
      const isAbsoluteUrl = z.string().url().safeParse(documentPath).success;
      const absolutePath = isAbsoluteUrl
        ? documentPath
        : `${window.location.origin}${documentPath.startsWith("/") ? "" : "/"}${documentPath}`;

      await runWithLicense(async () => {
        void documentViewer.loadDocument(absolutePath);
      });
    },
    onSuccess: () => {
      onLoad?.();
    },
    onError: (error: Error) => {
      onError?.(error);
    },
  });

  const mutateRef = useRef(mutate);
  mutateRef.current = mutate;

  const loadDocument = useCallback(() => {
    mutateRef.current();
  }, []);

  useEffect(() => {
    loadDocument();
  }, [loadDocument]);

  return null;
};
```

##### `registry/components/zoom-controls.tsx`

```typescript
"use client";

import { useZoom } from "@/hooks/use-zoom";

interface ZoomControlsProps {
  className?: string;
}

export const ZoomControls = ({ className }: ZoomControlsProps) => {
  const { zoomLevel, zoomIn, zoomOut } = useZoom();

  return (
    <div
      className={
        className ?? "flex items-center gap-2 p-2 bg-white rounded-lg shadow"
      }
    >
      <button
        onClick={zoomOut}
        className="p-2 hover:bg-gray-100 rounded"
        aria-label="Zoom out"
      >
        -
      </button>
      <span className="min-w-[60px] text-center">
        {Math.round(zoomLevel * 100)}%
      </span>
      <button
        onClick={zoomIn}
        className="p-2 hover:bg-gray-100 rounded"
        aria-label="Zoom in"
      >
        +
      </button>
    </div>
  );
};
```

##### `registry/components/zoomer.tsx`

**Changes from original:**
- Added actual zoom functionality using `useZoom` hook
- Replaced `@/lib/cn` → inline `cn` function
- Replaced `@/components/ui/input` → shadcn registry dependency

```typescript
"use client";

import { useState, useEffect } from "react";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
import { Minus, Plus } from "lucide-react";
import { Input } from "@/components/ui/input";
import { useZoom } from "@/hooks/use-zoom";

function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

interface ZoomerProps {
  className?: string;
}

export const Zoomer = ({ className }: ZoomerProps) => {
  const { zoomLevel, zoomIn, zoomOut, zoomTo } = useZoom();
  const [inputValue, setInputValue] = useState(
    String(Math.round(zoomLevel * 100))
  );

  // Sync input with actual zoom level
  useEffect(() => {
    setInputValue(String(Math.round(zoomLevel * 100)));
  }, [zoomLevel]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
  };

  const handleInputBlur = () => {
    const value = parseInt(inputValue, 10);
    if (!isNaN(value) && value > 0) {
      zoomTo(value / 100);
    } else {
      setInputValue(String(Math.round(zoomLevel * 100)));
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      handleInputBlur();
    }
  };

  return (
    <div
      data-testid="zoomer"
      className={cn(
        "flex w-12 flex-col items-center gap-1 rounded-2xl border border-slate-200 bg-white py-2",
        className
      )}
    >
      <button
        onClick={zoomIn}
        className="flex cursor-pointer items-center justify-center p-1 transition-colors hover:opacity-70"
        aria-label="Zoom in"
      >
        <Plus className="size-4 text-slate-950" strokeWidth={2} />
      </button>

      <div
        className="flex h-9 w-full items-center justify-center border-y"
        style={{ backgroundColor: "#fafafa", borderColor: "#e5e5e5" }}
      >
        <div className="flex items-center gap-0.5 p-1">
          <Input
            type="text"
            inputMode="numeric"
            value={inputValue}
            onChange={handleInputChange}
            onBlur={handleInputBlur}
            onKeyDown={handleKeyDown}
            className="h-auto w-6 border-transparent bg-transparent p-0 text-center text-xs leading-[1.4] text-slate-950 focus-visible:border-transparent focus-visible:ring-0 focus-visible:ring-offset-0"
          />
          <span className="text-xs font-medium leading-[1.2] tracking-tight text-neutral-600">
            %
          </span>
        </div>
      </div>

      <button
        onClick={zoomOut}
        className="flex cursor-pointer items-center justify-center p-1 transition-colors hover:opacity-70"
        aria-label="Zoom out"
      >
        <Minus className="size-4 text-slate-950" strokeWidth={2} />
      </button>
    </div>
  );
};
```

---

### Phase 3: Documentation Content

#### 3.1 Create meta.json files for navigation

`content/docs/components/meta.json`:
```json
{
  "title": "Components",
  "pages": [
    "load-webviewer-core",
    "load-pdfnet",
    "webviewer-provider",
    "viewer-canvas",
    "viewer-element",
    "scroll-view-container",
    "document",
    "zoom-controls",
    "zoomer"
  ]
}
```

`content/docs/hooks/meta.json`:
```json
{
  "title": "Hooks",
  "pages": ["use-core-instance", "use-zoom", "use-run-with-license"]
}
```

`content/docs/context/meta.json`:
```json
{
  "title": "Context",
  "pages": ["webviewer-context"]
}
```

#### 3.2 Create documentation helper components

##### `components/docs/install-command.tsx`

```tsx
"use client";

import { useState } from "react";

interface InstallCommandProps {
  name: string;
}

export const InstallCommand = ({ name }: InstallCommandProps) => {
  const [copied, setCopied] = useState(false);
  const command = `npx shadcn add https://webviewer-ui-blocks.vercel.app/r/${name}.json`;

  const handleCopy = () => {
    navigator.clipboard.writeText(command);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="relative">
      <pre className="rounded-lg bg-slate-950 p-4 text-sm text-slate-50 overflow-x-auto">
        <code>{command}</code>
      </pre>
      <button
        onClick={handleCopy}
        className="absolute top-2 right-2 p-2 rounded hover:bg-slate-800 text-slate-400 hover:text-slate-200"
      >
        {copied ? "Copied!" : "Copy"}
      </button>
    </div>
  );
};
```

##### `components/docs/component-source.tsx`

```tsx
import { readFileSync } from "fs";
import { join } from "path";

interface ComponentSourceProps {
  name: string;
  type?: "component" | "hook" | "context" | "lib";
}

export const ComponentSource = ({
  name,
  type = "component",
}: ComponentSourceProps) => {
  const paths: Record<string, string> = {
    component: `registry/components/${name}.tsx`,
    hook: `registry/hooks/${name}.ts`,
    context: `registry/context/${name}.tsx`,
    lib: `registry/lib/${name}.ts`,
  };

  const filePath = join(process.cwd(), paths[type]);

  try {
    const source = readFileSync(filePath, "utf-8");
    return (
      <pre className="rounded-lg bg-slate-950 p-4 text-sm text-slate-50 overflow-x-auto">
        <code>{source}</code>
      </pre>
    );
  } catch {
    return <div>Source not found</div>;
  }
};
```

#### 3.3 Example MDX documentation page

`content/docs/components/document.mdx`:

```mdx
---
title: Document
description: Loads a PDF document into the viewer
---

import { InstallCommand } from "@/components/docs/install-command";
import { ComponentSource } from "@/components/docs/component-source";

The Document component loads a PDF document into the WebViewer.

## Installation

<InstallCommand name="document" />

## Dependencies

This component requires:
- `@tanstack/react-query`
- `zod`

## Usage

```tsx
import { LoadWebviewerCore } from "@/components/load-webviewer-core";
import { LoadPDFNet } from "@/components/load-pdfnet";
import { WebViewerProvider } from "@/context/webviewer-context";
import { ViewerCanvas } from "@/components/viewer-canvas";
import { Document } from "@/components/document";

export function PDFViewer({ url }: { url: string }) {
  return (
    <LoadWebviewerCore>
      <LoadPDFNet>
        <WebViewerProvider>
          <div style={{ height: "100vh", display: "flex", flexDirection: "column" }}>
            <ViewerCanvas>
              <Document
                documentPath={url}
                onLoad={() => console.log("Document loaded")}
                onError={(error) => console.error("Load error:", error)}
              />
            </ViewerCanvas>
          </div>
        </WebViewerProvider>
      </LoadPDFNet>
    </LoadWebviewerCore>
  );
}
```

## Props

| Prop | Type | Description |
|------|------|-------------|
| `documentPath` | `string` | URL to the PDF document (relative or absolute) |
| `onLoad` | `() => void` | Callback when document loads successfully |
| `onError` | `(error: Error) => void` | Callback when document fails to load |

## Environment Variables

Make sure to set the following environment variables:

```bash
NEXT_PUBLIC_PDFTRON_PATH=/webviewer/lib
NEXT_PUBLIC_APRYSE_LICENSE=your-license-key
```

## Source

<ComponentSource name="document" />
```

---

### Phase 4: Build & Deploy

1. **Build the registry**

   ```bash
   npx shadcn build
   ```

   This generates `public/r/*.json` files

2. **Build the site**

   ```bash
   npm run build
   ```

3. **Deploy to Vercel**
   ```bash
   vercel deploy
   ```

---

## User Installation Flow

Users will install components like this:

```bash
# Initialize shadcn in their project (if not already)
npx shadcn@latest init

# Add components from webviewer-ui-blocks
npx shadcn add https://webviewer-ui-blocks.vercel.app/r/viewer-canvas.json
npx shadcn add https://webviewer-ui-blocks.vercel.app/r/document.json
npx shadcn add https://webviewer-ui-blocks.vercel.app/r/zoomer.json

# Dependencies are automatically resolved
# e.g., adding viewer-canvas also installs scroll-view-container, viewer-element, use-core-instance, etc.
```

---

## Environment Variables (User Setup)

Users need to configure these environment variables:

```bash
# Path to WebViewer library files (copy from node_modules/@pdftron/webviewer/public)
NEXT_PUBLIC_PDFTRON_PATH=/webviewer/lib

# Apryse license key
NEXT_PUBLIC_APRYSE_LICENSE=your-license-key
```

---

## Dependency Graph

```
webviewer-types (foundation)
    ↓
webviewer-context
    ↓
use-core-instance
    ├── use-zoom
    │   ├── zoom-controls
    │   └── zoomer (+ button, input from shadcn)
    └── use-run-with-license
        └── document (+ @tanstack/react-query, zod)

load-webviewer-core (standalone loader)
load-pdfnet (standalone loader)

viewer-element ← use-core-instance
scroll-view-container ← use-core-instance
    ↓
viewer-canvas (combines scroll-view-container + viewer-element)
```

---

## Verification & Testing

1. **Build verification**

   ```bash
   npx shadcn build  # Should generate all public/r/*.json files
   npm run build     # Should build docs site without errors
   ```

2. **Registry validation**
   - Each `public/r/*.json` should be valid JSON
   - All `registryDependencies` should resolve
   - All file paths should exist

3. **Installation test**

   ```bash
   # Create test project
   npx create-next-app@latest test-install --typescript --tailwind
   cd test-install
   npx shadcn@latest init

   # Test installation from local dev server
   npx shadcn add http://localhost:3000/r/viewer-canvas.json

   # Verify files are created in correct locations
   ```

4. **Documentation test**
   - Navigate all docs pages
   - Verify code blocks render correctly
   - Test copy buttons
   - Verify search works
